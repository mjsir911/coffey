% javascript conversion shit

/binary {
  3 -2 roll
  exch 5 1 roll
  4 -1 roll normalize
  2 -1 roll pushstr
  2 -1 roll normalize
} def

/trinary {
	4 -2 roll
	exch 6 1 roll
	7 -1 roll normalize
	3 -1 roll pushstr
	4 -1 roll normalize
	2 -1 roll pushstr
	2 -1 roll normalize
} def

/operators <<
	/mul { ( * ) binary }
	/add { ( + ) binary }
	/eq  { ( == ) binary }
	/ifelse  { ( ? ) ( : ) trinary }
>> def


/getField {
	exch
	(this.getField\(') pushstr
	exch pushstr
	('\).value) pushstr
} def

/normalize { % returns a string
	dup type /nametype eq {
		dup xcheck {
			bigdict exch exec get unroll (.) join
			getField
		} {
			dup length string cvs
			getField
		} ifelse
	} {
	dup type /arraytype eq {
		dup xcheck {
			exch
			(\() pushstr
			exch { normalize } forall
			(\)) pushstr
		} {
			(ps2js) /typecheck signalerror
		} ifelse
	} {
	dup type /integertype eq {
		exch dup 3 1 roll cvs length restinterval
	} {
	dup type /stringtype eq {
		dup xcheck {
			pushstr
		} {
			exch
			(") pushstr
			exch pushstr
			(") pushstr
		} ifelse
	} { 
		(ps2js) /typecheck signalerror
	}
	ifelse
	} ifelse
	} ifelse
	} ifelse
} def

/restinterval { % str start restinterval (substr to end)
	exch
	dup length
	3 -1 roll dup
	3 1 roll sub
	getinterval
} def

/pushstr { % buf newstr pushstr shiftbuf
	dup length
	3 -1 roll dup
	4 -1 roll
	0 exch putinterval
	exch restinterval
} def

/ps2js { % {code} ps2js (javascript code)
	{
		dup operators exch known {
			1000 string dup % hope
			(\() pushstr
			% 3 -1 roll
			3 -1 roll operators exch get exec
			(\)) pushstr
			length exch dup length 3 -1 roll sub 
			0 exch getinterval
			cvx
		} if
	} forall
	dup length
	(event.target.value = )
	dup length
	3 -1 roll add string dup
	3 -1 roll pushstr
	3 -1 roll pushstr
	pop
} def

% { /asd (Yes) eq { 1 } { 0 } ifelse /osd (Yes) eq { 1 } { 0 } ifelse add } ps2js =
% { /asd (Yes) eq { 1 } { 0 } ifelse } ps2js =
% asd == "Yes" ? ( 1 ) : ( 0 )
